SWIFT ( PROGRAMMING LANGUAGE )
Swift is a general - purpose , multi - paradigm , compiled programming language developed by Apple Inc. for iOS , macOS , watchOS , tvOS , Linux and z / OS .
Swift is designed to work with Apple 's Cocoa and Cocoa Touch frameworks and the large body of existing Objective - C code written for Apple products .
It is built with the open source LLVM compiler framework and has been included in Xcode since version 6 , released in 2014 .
On Apple platforms , it uses the Objective - C runtime library which allows C , Objective - C , C++ and Swift code to run within one program .
Apple intended Swift to support many core concepts associated with Objective - C , notably dynamic dispatch , widespread late binding , extensible programming and similar features , but in a " safer " way , making it easier to catch software bugs ; Swift has features addressing some common programming errors like null pointer dereferencing and provides syntactic sugar to help avoid the pyramid of doom .
Swift supports the concept of protocol extensibility , an extensibility system that can be applied to types , structs and classes , which Apple promotes as a real change in programming paradigms they term " protocol - oriented programming " ( similar to traits ) .
Swift was introduced at Apple 's 2014 Worldwide Developers Conference ( WWDC ) .
It underwent an upgrade to version 1.2 during 2014 and a more major upgrade to Swift 2 at WWDC 2015 .
Initially a proprietary language , version 2.2 was made open - source software under the Apache License 2.0 on December 3 , 2015 , for Apple 's platforms and Linux .
Through version 3.0
the syntax of Swift went through significant evolution , with the core team making source stability a focus in later versions .
In the first quarter of 2018 Swift surpassed Objective - C in measured popularity .
Swift 4.0 , released in 2017 , introduced several changes to some built - in classes and structures .
Code written with previous versions of Swift can be updated using the migration functionality built into Xcode .
HISTORY Section::::History .
Development of Swift started in July 2010 by Chris Lattner , with the eventual collaboration of many other programmers at Apple .
Swift took language ideas " from Objective - C , Rust , Haskell , Ruby , Python , C # , CLU , and far too many others to list " .
On June 2 , 2014 , the Apple Worldwide Developers Conference ( WWDC ) application became the first publicly released app written with Swift .
A beta version of the programming language was released to registered Apple developers at the conference , but the company did not promise that the final version of Swift would be source code compatible with the test version .
Apple planned to make source code converters available if needed for the full release .
The Swift Programming Language , a free 500-page manual , was also released at WWDC , and is available on the iBooks Store and the official website .
Swift reached the 1.0 milestone on September 9 , 2014 , with the Gold Master of Xcode 6.0 for iOS .
Swift 1.1 was released on October 22 , 2014 , alongside the launch of Xcode 6.1 .
Swift 1.2 was released on April 8 , 2015 , along with Xcode 6.3 .
Swift 2.0 was announced at WWDC 2015 , and was made available for publishing apps in the App Store in September 21 , 2015 .
Swift 3.0 was released on September 13 , 2016 .
Swift 4.0 was released on September 19 , 2017 .
Swift 4.1 was released on March 29 , 2018 .
Swift won first place for Most Loved Programming Language in the Stack Overflow Developer Survey 2015 and second place in 2016 .
In December 2015 , IBM announced its Swift Sandbox website , which allows developers to write Swift code in one pane and display output in another .
The Swift Sandbox was deprecated in January 2018 .
During the WWDC 2016 , Apple announced an iPad exclusive app , named Swift Playgrounds , intended to teach people how to code in Swift .
The app is presented in a 3D video game - like interface which provides feedback when lines of code are placed in a certain order and executed .
In January 2017 , Chris Lattner announced his departure from Apple for a new position with Tesla Motors , with the Swift project lead role going to team veteran Ted Kremenek .
VERSION HISTORY Section::::Version History . !
Date ! !
Version FEATURES Section::::Features .
Swift is an alternative to the Objective - C language that employs modern programming - language theory concepts and strives to present a simpler syntax .
During its introduction , it was described simply as " Objective - C without the C " .
By default , Swift does not expose pointers and other unsafe accessors , in contrast to Objective - C , which uses pointers pervasively to refer to object instances .
Also , Objective - C 's use of a Smalltalk - like syntax for making method calls has been replaced with a dot - notation style and namespace system more familiar to programmers from other common object - oriented ( OO ) languages like Java or C # .
Swift introduces true named parameters and retains key Objective - C concepts , including protocols , closures and categories , often replacing former syntax with cleaner versions and allowing these concepts to be applied to other language structures , like enumerated types ( enums )
SYNTACTIC SUGAR Section::::Syntactic sugar .
Under the Cocoa and Cocoa Touch environments , many common classes were part of the Foundation Kit library .
This included the NSString string library ( using Unicode ) , the NSArray and NSDictionary collection classes , and others .
Objective - C provided various bits of syntactic sugar to allow some of these objects to be created on - the - fly within the language , but once created , the objects were manipulated with object calls .
For instance , in Objective - C concatenating two NSStrings required method calls similar to this : In Swift , many of these basic types have been promoted to the language 's core , and can be manipulated directly .
For instance , strings are invisibly bridged to NSString ( when Foundation is imported ) and can now be concatenated with the codice_1 operator , allowing greatly simplified syntax ; the prior example becoming : ACCESS CONTROL Section::::Access control .
Swift supports five access control levels for symbols : codice_2 , codice_3 , codice_4 , codice_5 , and codice_6 .
Unlike many object - oriented languages , these access controls ignore inheritance hierarchies : codice_6 indicates that a symbol is accessible only in the immediate scope
, codice_5 indicates it is accessible only from within the file ,
codice_4 indicates it is accessible within the containing module , codice_3 indicates it is accessible from any module , and codice_2 ( only for classes and their methods ) indicates that the class may be subclassed outside of the module .
OPTIONALS AND CHAINING Section::::Optionals and chaining .
An important new feature in Swift is option types , which allow references or values to operate in a manner similar to the common pattern in C , where a pointer may refer to a value or may be null .
This implies that non - optional types can not result in a null - pointer error ; the compiler can ensure this is not possible .
Optional types are created with the codice_12 mechanism — to make an Integer that is nullable , one would use a declaration similar to codice_13 .
As in C # , Swift also includes syntactic sugar for this , allowing one to indicate a variable is optional by placing a question mark after the type name , codice_14 .
Variables or constants that are marked optional either have a value of the underlying type or are codice_15 .
Optional types wrap the base type , resulting in a different instance .
codice_16 and codice_17 are fundamentally different types , the latter has more in common with codice_18 than codice_16 .
To access the value inside , assuming it is not nil , it must be unwrapped to expose the instance inside .
This is performed with the codice_20 operator :
In this case , the codice_20 operator unwraps codice_22 to expose the instance inside , allowing the method call to be made on it .
If codice_22 is nil , a null - pointer error occurs .
This can be annoying in practice , so Swift also includes the concept of optional chaining to test whether the instance is nil and then unwrap it if it is non - null :
In this case the runtime only calls codice_24 if codice_22 is not nil , suppressing the error .
Normally this requires the programmer to test whether codice_26 is nil before proceeding .
The origin of the term chaining comes from the more common case where several method calls / getters are chained together .
For instance : can be reduced to :
The codice_27 syntax circumvents the pyramid of doom .
Swift 2 introduced the new keyword codice_28 for cases in which code should stop executing if some condition is unmet :
Using codice_28 has three benefits .
While the syntax can act as an codice_30 statement , its primary benefit is inferring non - nullability .
Where an codice_30 statement requires a case , codice_28 assumes the case based on the condition provided .
Also , since codice_28 contains no scope , with exception of the codice_34 closure , codice_35 is presented as an unwrapped optional to the guard 's super - scope .
Lastly , if the codice_28 statement 's test fails , Swift requires the codice_34 to exit the current method or loop , ensuring codice_35 never is accessed when codice_15 .
This is performed with the keywords codice_40 , codice_41 , codice_42 , or codice_43 .
Objective - C was weakly typed , and allowed any method to be called on any object at any time .
If the method call failed , there was a default handler in the runtime that returned nil .
That meant that no unwrapping or testing was needed , the equivalent statement in Objective - C : would return nil and this could be tested .
However , this also demanded that all method calls be dynamic , which introduces significant overhead .
Swift 's use of optionals provides a similar mechanism for testing and dealing with nils , but does so in a way that allows the compiler to use static dispatch because the unwrapping action is called on a defined instance ( the wrapper ) , versus occurring in the runtime dispatch system .
VALUE TYPES Section::::Value types .
In many object - oriented languages , objects are represented internally in two parts .
The object is stored as a block of data placed on the [ [ Heap ( data structure)heap ] ] , while the name ( or " handle " ) to that object is represented by a [ [ Pointer ( computer programming)pointer ] ] .
Objects are passed between methods by copying the value of the pointer , allowing the same underlying data on the heap to be accessed by anyone with a copy .
In contrast , basic types like integers and floating point values are represented directly ; the handle contains the data , not a pointer to it , and that data is passed directly to methods by copying .
These styles of access are termed pass - by - reference in the case of objects , and pass - by - value for basic types .
Both concepts have their advantages and disadvantages .
Objects are useful when the data is large , like the description of a window or the contents of a document .
In these cases , access to that data is provided by copying a 32- or 64-bit value , versus copying an entire data structure .
However , smaller values like integers are the same size as pointers ( typically both are one [ [ Word ( computer architecture)word ] ] ) , so there is no advantage to passing a pointer , versus passing the value .
Also , pass - by - reference inherently requires a dereferencing operation , which can produce noticeable overhead in some operations , typically those used with these basic value types , like mathematics .
Similarly to C # and in contrast to most other OO languages , Swift offers built - in support for objects using either pass - by - reference or pass - by - value semantics , the former using the codice_44 declaration and the latter using codice_45 .
Structs in Swift have almost all the same features as classes : methods , implementing protocols , and using the extension mechanisms .
For this reason , Apple terms all data generically as instances , versus objects or values .
Structs do not support inheritance , however .
The programmer is free to choose which semantics are more appropriate for each data structure in the application .
Larger structures like windows would be defined as classes , allowing them to be passed around as pointers .
Smaller structures , like a 2D point , can be defined as structs , which will be pass - by - value and allow direct access to their internal data with no dereference .
The performance improvement inherent to the pass - by - value concept is such that Swift uses these types for almost all common data types , including codice_46 and codice_47 , and types normally represented by objects , like codice_16 and codice_49 .
Using value types can result in significant performance improvements in user applications as well .
To ensure that even the largest structs do not cause a performance penalty when they are handed off , Swift uses [ [ copy on write ] ]
so that the objects are copied only if and when the program attempts to change a value in them .
This means that the various accessors have what is in effect a pointer to the same data storage , but this takes place far below the level of the language , in the computer 's [ [ memory management unit ] ] ( MMU ) .
So while the data is physically stored as one instance in memory , at the level of the application , these values are separate , and physical separation is enforced by copy on write only if needed .
PROTOCOL - ORIENTED PROGRAMMING Section::::Protocol - oriented programming .
A key feature of Objective - C is its support for categories , methods that can be added to extend classes at runtime .
Categories allow extending classes in - place to add new functions with no need to subclass or even have access to the original [ [ source code ] ] .
An example might be to add [ [ spell checker ] ]
support to the base codice_50 class , which means all instances of NSString in the application gain spell checking .
The system is also widely used as an organizational technique , allowing related code to be gathered into library - like extensions .
Swift continues to support this concept , although they are now termed extensions , and declared with the keyword codice_51 .
Unlike Objective - C , Swift can also add new properties accessors , types and enums to extant instances .
Another key feature of Objective - C is its use of [ [ Protocol_(object - oriented_programming)protocols ] ] , known in most modern languages as interfaces .
Protocols promise that a particular class implements a set of methods , meaning that other objects in the system can call those methods on any object supporting that protocol .
This is often used in modern OO languages as a substitute for [ [ multiple inheritance ] ] , although the feature sets are not entirely similar .
A common example of a protocol in Cocoa is the codice_52 protocol , which defines one method , codice_53 , that implements [ [ object copying#deep copydeep copying ] ] on objects .
In Objective - C , and most other languages implementing the protocol concept , it is up to the programmer to ensure that the required methods are implemented in each class .
Swift adds the ability to add these methods using extensions , and to use [ [ generic programming ] ]
( generics ) to implement them .
Combined , these allow protocols to be written once and support a wide variety of instances .
Also , the extension mechanism can be used to add protocol conformance to an object that does not list that protocol in its definition .
For example , a protocol might be declared called codice_54 , which ensures that instances that conform to the protocol implement a codice_55 method that returns a codice_16 .
In Swift , this can be declared with code like this :
This protocol can now be added to String , with no access to the base class 's source :
In Swift , like many modern languages supporting interfaces , protocols can be used as types , which means variables and methods can be defined by protocol instead of their specific type :
It does not matter what sort of instance codice_57 is , the compiler will ensure that it conforms to the protocol and thus this code is safe .
This syntax also means that collections can be based on protocols also , like codice_58 .
As Swift treats structs and classes as similar concepts , both extensions and protocols are extensively used in Swift 's runtime to provide a rich API based on structs .
For instance , Swift uses an extension to add the codice_59 protocol to many of their basic types , like Strings and Arrays , allowing them to be compared with the codice_60 operator .
A concrete example of how all of these features interact can be seen in the concept of default protocol implementations : This function defines a method that works on any instance conforming to codice_59 , providing a not equals function .
Any instance , class or struct , automatically gains this implementation simply by conforming to codice_59 .
As many instances gain codice_59 through their base implementations or other generic extensions , most basic objects in the runtime gain equals and not equals with no code .
This combination of protocols , defaults , protocol inheritance , and extensions allows many of the functions normally associated with classes and inheritance to be implemented on value types .
Properly used , this can lead to dramatic performance improvements with no significant limits in API .
This concept is so widely used within Swift , that Apple has begun calling it a protocol - oriented programming language .
They suggest addressing many of the problem domains normally solved though classes and inheritance using protocols and structs instead .
LIBRARIES , RUNTIME AND DEVELOPMENT Section::::Libraries , runtime and development .
Swift uses the same runtime as the extant Objective - C system , but requires iOS 7 or macOS 10.9 or higher .
Swift and Objective - C code can be used in one program , and by extension , C and C++ also .
In contrast to C , C++ code can not be used directly from Swift .
An Objective - C or C wrapper must be created between Swift and C++ .
In the case of Objective - C , Swift has considerable access to the object model , and can be used to subclass , extend and use Objective - C code to provide protocol support .
The converse is not true : a Swift class can not be subclassed in Objective - C. To aid development of such programs , and the re - use of extant code , Xcode 6 offers a semi - automated system that builds and maintains a bridging header to expose Objective - C code to Swift .
This takes the form of an additional [ [ header file ] ] that simply defines or imports all of the Objective - C symbols that are needed by the project 's Swift code .
At that point , Swift can refer to the types , functions , and variables declared in those imports as though they were written in Swift .
Objective - C code can also use Swift code directly , by importing an automatically maintained header file with Objective - C declarations of the project 's Swift symbols .
For instance , an Objective - C file in a mixed project called " MyApp " could access Swift classes or functions with the code codice_64 .
Not all symbols are available through this mechanism , however — use of Swift - specific features like generic types , non - object optional types , sophisticated enums , or even Unicode identifiers may render a symbol inaccessible from Objective - C. Swift also has limited support for attributes , metadata that is read by the development environment , and is not necessarily part of the compiled code .
Like Objective - C , attributes use the codice_65 syntax , but the currently available set is small .
One example is the codice_66 attribute , which marks a given value in the code as an outlet , available for use within [ [ Interface Builder ] ]
( IB ) .
An outlet is a device that binds the value of the on - screen display to an object in code .
MEMORY MANAGEMENT Section::::Memory management .
Swift uses [ [ Automatic Reference Counting ] ]
( ARC ) to [ [ Memory managementmanage memory ] ] .
Apple used to require manual memory management in Objective - C , but introduced ARC in 2011 to allow for easier memory allocation and deallocation .
One problem with ARC is the possibility of creating a [ [ Reference counting#reference cyclestrong reference cycle ] ] , where objects reference each other in a way that you can reach the object you started from by following references ( e.g. A references B , B references A ) .
This causes them to become leaked into memory as they are never released .
Swift provides the keywords codice_67 and codice_68 to prevent strong reference cycles .
Typically a parent - child relationship would use a strong reference while a child - parent would use either codice_67 reference , where parents and children can be unrelated , or codice_68 where a child always has a parent , but parent may not have a child .
Weak references must be optional variables , since they can change and become codice_15 .
A closure within a class can also create a strong reference cycle by capturing self references .
Self references to be treated as weak or unowned can be indicated using a capture list .
DEBUGGING AND OTHER ELEMENTS Section::::Debugging and other elements .
A key element of the Swift system is its ability to be cleanly debugged and run within the development environment , using a [ [ read – eval – print loop ] ]
( REPL ) , giving it interactive properties more in common with the scripting abilities of Python than traditional [ [ system programming ] ] languages .
The REPL is further enhanced with the new concept playgrounds .
These are interactive views running within the Xcode environment that respond to code or debugger changes on - the - fly .
Playgrounds allow programmers to add in Swift code along with markdown documentation .
If some code changes over time or with regard to some other ranged input value , the view can be used with the Timeline Assistant to demonstrate the output in an animated way .
In addition , Xcode has debugging features for Swift development including breakpoints , step through and step over statements , as well as UI element placement breakdowns for app developers .
Apple says that Swift is " an industrial - quality programming language that 's as expressive and enjoyable as a scripting language " .
PERFORMANCE Section::::Performance .
Many of the features introduced with Swift also have well - known performance and safety trade - offs .
Apple has implemented [ [ Optimizing compileroptimizations ] ] that reduce this overhead .
COMPARISONS TO OTHER LANGUAGES Section::::Comparisons to other languages .
Swift is similar to C in various ways :
* Most C operators are used in Swift , but there are some new operators .
* [ [ Curly braces ] ]
are used to group statements .
* Variables are assigned using an [ [ equals sign ] ] , but compared using [ [ = = two consecutive equals signs ] ] .
A new identity operator , = = = , is provided to check if two data elements refer to the same [ [ Pointer ( computing)object ] ] .
* Control statements
codice_72 , codice_30 , and codice_74 are similar , but have extended functions , e.g. , a codice_74 that takes non - integer cases , codice_72 and codice_30 supporting pattern matching and conditionally unwrapping optionals , etc .
*
[ [ Square brackets ] ] are used with [ [ Array data structurearrays ] ] , both to declare them and to get a value at a given index in one of them .
It also has similarities to Objective - C : * Basic numeric types ( codice_78 ) * Class methods are inherited , like instance methods ; codice_79 in class methods is the class the method was called on .
* Similar codice_80 ... codice_81 enumeration syntax .
Differences from Objective - C include : *
Statements do not need to end with semicolons ( codice_82 ) , though these must be used to allow more than one statement on a line .
* No header files .
* Uses [ [ type inference ] ] .
*
[ [ Generic programming ] ] .
* Functions are [ [ first class functionfirst - class ] ] objects .
* Enumeration cases can have associated data ( [ [ algebraic data type]]s ) .
* Operators can be redefined for classes ( [ [ operator overloading ] ] ) , and new operators can be defined .
* Strings fully support [ [ Unicode ] ] .
Most Unicode characters can be used in either identifiers or operators .
*
No [ [ exception handling ] ] .
Swift 2 introduces a different and incompatible error - handling model .
*
Several notoriously error - prone behaviors of earlier [ [ List of C - family programming languagesC - family languages ] ] have been changed : *
[ [ Pointer ( computer programming)Pointers ] ] are not exposed by default .
There is no need for the programmer to keep track of and mark names for referencing or dereferencing .
* Assignments return no value .
This prevents the common error of writing codice_83 instead of codice_84 by throwing a compile - time error .
*
No need to use codice_42 statements in codice_86 blocks .
Individual cases do not fall through to the next case unless the codice_87 statement is used .
* Variables and constants are always initialized and array bounds are always checked .
*
[ [ Integer overflow]]s , which result in [ [ undefined behavior ] ]
for signed integers in C , are trapped as a run - time error in Swift .
Programmers can choose to allow overflows by using the special arithmetical operators codice_88 , codice_89 , codice_90 , codice_91 and codice_92 .
The properties codice_93 and codice_94 are defined in Swift for all integer types and can be used to safely check for potential overflows , versus relying on constants defined for each type in external libraries .
* The one - statement form of codice_30 and codice_72 , which allows for the omission of braces around the statement , is unsupported .
* C - style enumeration
codice_97 , which is prone to [ [ off - by - one error]]s , is unsupported ( from Swift 3 onward ) .
* The pre- and post-
[ [ increment and decrement operators ] ]
( codice_98 , codice_99 ... ) are unsupported ( from Swift 3 onward ) , more so since C - style codice_80 statements are also unsupported from Swift 3 onward .
DEVELOPMENT AND OTHER IMPLEMENTATIONS Section::::Development and other implementations .
Since the language is open - source , there are prospects of it being ported to the web .
Some web frameworks have already been developed , such as [ [ IBM ] ] 's [ [ Kitura ] ] , [ [ Perfect ( server framework)Perfect ] ] and [ [ Vapor ( Server - side Swift)Vapor ] ] .
An official " Server APIs " work group has also been started by Apple , with members of the Swift developer community playing a central role .
A second free implementation of Swift that targets [ [ Cocoa ( API)Cocoa ] ] , [ [ Microsoft ] ] 's [ [ Common Language Infrastructure ] ]
( [ [ .NET Framework .
NET ] ] ) , and the [ [ Java ( software platform)Java ] ] and [ [ Android ( operating system)Android ] ]
platform exists as part of the Elements Compiler from [ [ RemObjects Software ] ] .
SEE ALSO
* [ [ Comparison of programming languages ] ]
*
[ [ Objective - C ] ]
* [ [ Kotlin ( programming language ) ] ] * [ [ Python ( programming language ) ] ]
REFERENCES
EXTERNAL LINKS
* Swift at [ [ Apple Developer ] ]
* Server - side
Swift
* Swift for IBM z / OS * Swift for Linux on z Systems Section::::External links .
[ [ Category : Apple Inc. ] ]
[ [ Category : Computer - related introductions in 2014 ] ]
[ [ Category : Object - oriented programming languages ] ]
[ [ Category : Pattern matching programming languages ] ]
[ [ Category : Programming languages ] ]
[ [ Category : Programming languages created in 2014 ] ]
[ [ Category : Software using the Apache license ] ]
[ [ Category :
Statically typed programming languages ] ]
[ [ Category :
Systems programming languages ] ]